import Foundation

let aNOT = 5.291772106712*pow(10,-11) // Bohr's Radius h-bar^2/(mass*(electron charge)^2)
let max = 1 as Double, min = 0 as Double // Integration domain

// What is the true answer??
// Must equal 1
let trueAnswer = 1 as Double
print("True Answer: \(trueAnswer)")

func analyticalIntegral(_ Radius: Double) -> Double {
	
	let exponential = exp(-1.0*Radius/aNOT)
	
	// The integrated function for H2+ is (1+R/a0+1/3(R/a0)^3)*e^(-1R/a0)
	return (1.0 + Radius/aNOT + 1.0/3.0*pow(Radius/aNOT,3))*exponential
}

func MonteCarloIntegration(_ sampleSize:Int) -> Double {
	var value = 0 as Double
	var sumOfFuncValues = 0 as Double

	for _ in 0..<sampleSize {
		// Generate "random" number by adding the min to the product between the difference of b & a and ξ, which is the uniformly distributed between zero and one. [X = min + ξ(max-min)]
		value = min + (max-min) * Double(arc4random()) / Double(UINT32_MAX)

		// Sum up the results from the function with the generated value
		// Change "analyticalIntegral" to your function
		// "-9" is the average distance between atoms (nm)
		// However, with "-12", the error is very small compared to "-9"...
		sumOfFuncValues += analyticalIntegral(value * pow(10,-9))
	}

	let area = sumOfFuncValues * (max-min) / Double(sampleSize) // Calculate the area under all the points from the function.

	print("\(sampleSize),\(area),\(abs(area - trueAnswer) / trueAnswer * 100)")

	return area
}

MonteCarloIntegration(10)
MonteCarloIntegration(20)
MonteCarloIntegration(50)
MonteCarloIntegration(100)
MonteCarloIntegration(200)
MonteCarloIntegration(500)
MonteCarloIntegration(10000)
MonteCarloIntegration(20000)
MonteCarloIntegration(50000)
